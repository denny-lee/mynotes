-----------------------------
git init
git status
git add .
git status
// git rm --cached <file>...
git commit -m ""
git log
git remote add origin https://github.com/try-git/try_git.git
git push -u origin master (-u记住参数，以后直接git push)
git pull origin master 拉代码
git diff HEAD
git diff --staged
git reset octofamily/octodog.txt
git checkout -- octocat.txt		单个文件回退   #若继续该命令，则会删除掉刚刚的修改内容
git branch clean_up  新建一分支
git checkout clean_up	切换到这个分支
git rm '*.txt' 删除
git commit -m
git checkout master
git merge clean_up 合并clean_up到当前分支
git branch -d clean_up	清掉分支
git push


git reset --hard HEAD 全部回退到上次提交的版本
---------------------------------------
新建项目
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/denny-lee/knowledge_front.git
git push -u origin master
--------------------------------------
git tag 列出
git tag -l "v1.8.5*" 列出匹配的
创建tag
Git uses two main types of tags: lightweight and annotated.
A lightweight tag is very much like a branch that doesn’t change C it’s just a pointer to a specific commit.
Annotated tags, however, are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It’s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don’t want to keep the other information, lightweight tags are available too.

git tag v1.4-lw	简易版
git tag -a v1.4 -m "my version 1.4" 推荐使用这种方式，加备注

git show v1.4 显示信息

Tagging Later
You can also tag commits after you’ve moved past them. Suppose your commit history looks like this:
git log --pretty=oneline	查一下提交过的版本
如有一条9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
git tag -a v1.2 9fceb02		tag那个版本To tag that commit, you specify the commit checksum (or part of it)
git push origin v1.5	把tag，push到远程，默认只保存在本地
git push origin --tags	把所有tag推到远程，远程没有的会新增，有的不变

Checking out Tags
git checkout -b version2 v2.0.0		得到一个version2的版本
--------------------------------------

如果你已经做了一个提交(commit),但是你马上后悔了, 这里有两种截然不同的方法去处理这个问题:

1，创建一个新的提交(commit), 在新的提交里撤消老的提交所作的修改. 这种作法在你已经把代码发布的情况下十分正确.
git revert HEAD 		#push后撤销该次commit
git revert HEAD^上上次
然后再git commit
2，你也可以去修改你的老提交(old commit). 但是如果你已经把代码发布了,那么千万别这么做; git不会处理项目的历史会改变的情况,如果一个分支的历史被改变了那以后就不能正常的合并.
git commit --amend 用于修改上一次的提交信息，或漏提交文件等情况。

#取消已经暂存的文件。即，撤销先前"git add"的操作
git reset HEAD <file>... # 取消add操作并保留修改
#回退a.py这个文件的版本到上一个版本  
git reset HEAD^ a.py  
#向前回退到第3个版本  
git reset Csoft HEAD~3  #保留修改
#将本地的状态回退到和远程的一样  
git reset Chard origin/master 
--------------------------------------
修改之前提交过的user config信息，邮件，用户名等
git commit --amend --author="Author Name <email@address.com>"
For example, if your commit history is A-B-C-D-E-F with F as HEAD, and you want to change the author of C and D, then you would...

Specify git rebase -i B
change the lines for both C and D to edit
Once the rebase started, it would first pause at C
You would git commit --amend --author="Author Name <email@address.com>"
Then git rebase --continue
It would pause again at D
Then you would git commit --amend --author="Author Name <email@address.com>" again
git rebase --continue
The rebase would complete.

--------------------------------------
这句什么意思？
git checkout -f step-1


-----------------------------


解除state状态的文件：
git rm --cached <file>

正常提交：
建一个.gitIgnore，把排除的路径编辑好
git status
git add .
git commit -m ""
git remote -v
git push origin master

新项目：
git clone url dir

以后拉项目：
git pull url dir

解决冲突：
如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:

git stash
git pull
git stash pop
然后可以使用Git diff -w +文件名 来确认代码自动合并的情况.

反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:

git reset --hard
git pull
其中git reset是针对版本,如果想针对文件回退本地修改,使用
git checkout HEAD file/to/restore 

------------------------------------
配置ssh:
配置好username和email，全局
切到 ~/.ssh/目录，如果有，备份然后删除
ssh-keygen -t rsa -C "wb-lw252418@alibaba-inc.com"
“”里是email
如果不设置密码直接enter 3次
去.ssh/id_rsa.pub，把key配置到git上。
ok